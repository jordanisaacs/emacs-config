#+TITLE: EmacsConfig
#+AUTHOR: Jordan Isaacs

* early-init.el

#+begin_src emacs-lisp :tangle early-init.el
;;; early-init.el --- Early Initialization -*- lexical-binding: t; -*-
#+end_src

** Startup
Time the startup

#+begin_src emacs-lisp :tangle early-init.el
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "loaded Emacs in %0.03fs"
                     (float-time (time-subtract after-init-time before-init-time)))))
#+end_src

Lower GC for init

#+begin_src emacs-lisp :tangle early-init.el
(let ((normal-gc-cons-threshold gc-cons-threshold)
      (normal-gc-cons-percentage gc-cons-percentage)
      (normal-file-name-handler-alist file-name-handler-alist)
      (init-gc-cons-threshold most-positive-fixnum)
      (init-gc-cons-percentage 0.6))
  (setq gc-cons-threshold init-gc-cons-threshold
        gc-cons-percentage init-gc-cons-percentage
        file-name-handler-alist nil)
  (add-hook 'after-init-hook
            `(lambda ()
               (setq gc-cons-threshold ,normal-gc-cons-threshold
                     gc-cons-percentage ,normal-gc-cons-percentage
                     file-name-handler-alist ',normal-file-name-handler-alist))))
#+end_src

Redirect calls to `user-emacs-directory` to ~$XDG_DATA_DIR~ if not one of our
specified paths. Since we are using ~--init-directory NIX_STORE~ which is read only.

Make sure to also set the custom-file to a place outside the ~NIX_STORE~.

#+begin_src emacs-lisp :tangle early-init.el
(startup-redirect-eln-cache (expand-file-name "eln-cache/" user-emacs-directory))
(setq user-emacs-directory (concat (getenv "XDG_STATE_HOME") "/emacs"))
(setq custom-file (locate-user-emacs-file "/custom.el"))
#+end_src

Performance tweaks. Don't load default library and use fundamental-mode to reduce
number of hooks.

#+begin_src emacs-lisp :tangle early-init.el
(setq inhibit-default-init t)
(setq initial-major-mode 'fundamental-mode)
#+end_src

#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

Inhibit startup screen and messages.

#+begin_src emacs-lisp :tangle early-init.el
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)

(setq use-dialog-box nil)
(push '(undecorated . t) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)

(setq frame-inhibit-implied-resize t)
(defvar global-text-scale-adjust-resizes-frames t)
(push '(drag-internal-border . t) default-frame-alist)
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src

Lazy load hooks

#+begin_src emacs-lisp :tangle early-init.el
(defun run-hook-on (hook-var trigger-hooks)
  "Configure HOOK-VAR to be invoked exactly once when any of the TRIGGER-HOOKS
  are invoked *after* Emacs has initialized (to reduce false positives). Once
  HOOK-VAR is triggered, it is reset to nil.

  HOOK-VAR is a quoted hook.
  TRIGGER-HOOK is a list of quoted hooks and/or sharp-quoted functions."
  (dolist (hook trigger-hooks)
    (let ((fn (make-symbol (format "chain-%s-to-%s-h" hook-var hook)))
          running)
      (fset
       fn (lambda (&rest _)
            ;; Only trigger this after Emacs has initialized.
            (when (and after-init-time
                       (not running)
                       (boundp hook)
                       (symbol-value hook))
              ;; prevent infinite recursion
              (setq running t)
              ;; (setq hook-run-state (cons (cons hook-var t) hook-run-state))
              (run-hooks hook-var)
              (set hook-var nil))))
      (cond
       ((eq hook 'find-file-hook)
        ;; Advise `after-find-file' instead of using `find-file-hook'
        ;; because the latter is triggered too late (after the file has
        ;; opened and modes are all set up).
        (advice-add 'after-find-file :before fn '((depth . -101))))
       ((add-hook hook fn -101)))
      fn)))

(defvar first-input-hook ()
  "Transient hooks run before the first user input.")

(defvar first-file-hook ()
  "Transient hooks run before the first interactively opened file.")

(defvar first-buffer-hook ()
  "Transient hooks run before the first interactively opened buffer.")

(run-hook-on 'first-buffer-hook '(find-file-hook window-buffer-change-functions))
(run-hook-on 'first-file-hook '(find-file-hook dired-initial-position-hook))
(run-hook-on 'first-input-hook '(pre-command-hook))
#+end_src

** Stricter security

Emacs is essentially one huge security vulnerability, what with all the
dependencies it pulls in from all corners of the globe. Let's try to be a
*little* more discerning.

#+begin_src emacs-lisp :tangle early-init.el
(defvar gnutls-verify-error)
(defvar gnutls-algorithm-priority)
(defvar gnutls-min-prime-bits)
(defvar tls-checktrust)
(defvar tls-program)
(setq gnutls-verify-error noninteractive
      gnutls-algorithm-priority
      (when (boundp 'libgnutls-version)
        "SECURE128:+SECURE192:-VERS-ALL:+VERS-TLS1.3")
      ;; `gnutls-min-prime-bits' is set based on recommendations from
      ;; https://www.keylength.com/en/4/
      gnutls-min-prime-bits 3072
      tls-checktrust gnutls-verify-error
      ;; Emacs is built with gnutls.el by default, so `tls-program' won't
      ;; typically be used, but in the odd case that it does, we ensure a more
      ;; secure default for it (falling back to `openssl' if absolutely
      ;; necessary). See https://redd.it/8sykl1 for details.
      tls-program '("openssl s_client -connect %h:%p -CAfile %t -nbio -no_ssl3 -no_tls1 -no_tls1_1 -ign_eof"
                    "gnutls-cli -p %p --dh-bits=3072 --ocsp --x509cafile=%t \
  --strict-tofu --priority='SECURE192:+SECURE128:-VERS-ALL:+VERS-TLS1.2:+VERS-TLS1.3' %h"
                    ;; compatibility fallbacks
                    "gnutls-cli -p %p %h"))

#+end_src

* init.el

** Plumbing

*** Lexical bindings

#+begin_src emacs-lisp :tangle init.el
;;; -*- lexical-binding: t; -*-
#+end_src

*** Cleanup site-startup.el

Nix's site-startup.el adds `$NIX_PROFILES` paths to a variety of variables.
This is good for some variables, but not good for loading. Those paths are
mutable -- not reproducible. This fixes some weird shit that was happening
with font faces.

#+begin_src emacs-lisp :tangle init.el
(require 'cl-extra)
(require 'cl-lib)

(defun filter-nix-store (paths)
  (cl-remove-if-not
   (lambda (s)
     (string-prefix-p "/nix/store/" s))
   paths))

(setq native-comp-eln-load-path (filter-nix-store native-comp-eln-load-path))
(setq load-path (filter-nix-store load-path))
#+end_src

*** debug

#+begin_src emacs-lisp :tangle init.el
(eval-and-compile
  (when (getenv "DEBUG") (setq init-file-debug t))
  (setq debug-on-error (and (not noninteractive) init-file-debug)))
#+end_src

*** custom.el

Make sure to load our custom-file

#+begin_src emacs-lisp :tangle init.el
(load custom-file :no-error-if-file-is-missing)
#+end_src

*** use-package

#+begin_src emacs-lisp :tangle init.el
(eval-when-compile
  (require 'use-package))

(eval-and-compile
  (defun use-package-ensure-ignore (&rest _args) t)
  (setq use-package-ensure-function #'use-package-ensure-ignore)
  (setq use-package-always-defer t)
  (setq use-package-hook-name-suffix nil))

(if init-file-debug
    (progn
      (setq use-package-verbose t
            use-package-expand-minimally nil
            use-package-compute-statistics t
            debug-on-error t))
  (setq use-package-verbose nil
        use-package-expand-minimally t))

;; Needed for :bind
(use-package bind-key
  :ensure t)

#+end_src

**** Blackout

This adds the ~:blackout~ parameter to use-package. It changes the modeline.

#+begin_src emacs-lisp :tangle init.el
(use-package blackout
  :ensure t
  :functions blackout)
#+end_src


** Repeat mode

#+begin_src  emacs-lisp :tangle init.el
(use-package repeat
  ;; builtin
  :demand t
  :preface
  ;; https://old.reddit.com/r/emacs/comments/1adwnse/repeatmode_is_awesome_share_you_useful_configs/kk9vpif/
  (defun repeatify (repeat-keymap)
    "Set the `repeat-map' property on all commands bound in REPEAT-MAP."
    (named-let process ((keymap (symbol-value repeat-keymap)))
      (map-keymap
       (lambda (_key cmd)
	 (cond
          ((symbolp cmd) (put cmd 'repeat-map repeat-keymap))
          ((keymapp cmd) (process cmd))))
       keymap)))
  :config
  (repeat-mode t))

(use-package repeat-help
  :ensure t
  :after repeat
  :commands repeat-help-mode
  :demand t
  :init
  (setq repeat-help-key "C-h")
  (setq repeat-help-popup-type 'embark)
  (advice-add 'repeat-help--embark-indicate :before (lambda (&rest _) (require 'embark)))
  :config
  (repeat-help-mode t))
#+end_src

** Theming

*** Generic change hook

From [[https://www.gnu.org/software/emacs//manual/html_node/modus-themes/A-theme_002dagnostic-hook-for-theme-loading.html][modus themes manual]]

#+begin_src emacs-lisp :tangle init.el
(defvar my/after-enable-theme-hook nil
   "Normal hook run after enabling a theme.")

(defun my/run-after-enable-theme-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'after-enable-theme-hook))

(advice-add 'enable-theme :after #'my/run-after-enable-theme-hook)
#+end_src

*** hl-todo highlighting

#+begin_src emacs-lisp :tangle init.el
(use-package hl-todo
  :ensure t
  :commands (hl-todo-insert hl-todo-occur hl-todo-next hl-todo-previous)
  :custom
  (hl-todo-highlight-punctuation ":")
  (hl-todo-keyword-faces nil)
  :init
  (defvar-keymap hl-todo-repeat-map
    :repeat (:enter (hl-todo-insert) :exit (hl-todo-occur))
    "n" #'hl-todo-next
    "p" #'hl-todo-previous
    "o" #'hl-todo-occur)
  :config
  (keymap-set hl-todo-mode-map "C-c t p" #'hl-todo-previous)
  (keymap-set hl-todo-mode-map "C-c t n" #'hl-todo-next)
  (keymap-set hl-todo-mode-map "C-c t o" #'hl-todo-occur)
  (keymap-set hl-todo-mode-map "C-c t i" #'hl-todo-insert)
  :hook
  (prog-mode-hook . hl-todo-mode)
  (text-mode-hook . hl-todo-mode))
#+end_src

*** Modus themes

#+begin_src emacs-lisp :tangle init.el
(use-package modus-themes
  :ensure t
  :after hl-todo
  :commands modus-themes-load-theme
  :functions modus-themes--retrieve-palette-value modus-themes--current-theme-palette
  :preface
  (defun my/hl-todo-modus-undone ()
    (modus-themes-with-colors
      (add-to-list 'hl-todo-keyword-faces (cons "UNDONE" err))))
  :hook
  (hl-todo-mode-hook . my/hl-todo-modus-undone)
  (modus-themes-after-load-theme-hook . my/hl-todo-modus-undone)
  :init
  (modus-themes-load-theme 'modus-operandi))
#+end_src

** Emacs

#+begin_src emacs-lisp :tangle init.el
(use-package emacs
  :preface
  (defun my/replace-keys (alist replacements)
    "Replace multiple keys in ALIST according to REPLACEMENTS.
REPLACEMENTS should be a list of (old-key . new-key) pairs.
Returns the modified ALIST."
    (dolist (replacement replacements alist)
      (my/replace-key alist (car replacement) (cdr replacement))))

  (defun my/replace-key (alist old-key new-key)
    "Replace OLD-KEY with NEW-KEY in ALIST."
    (let ((pair (assq old-key alist)))
      (when pair
        (setcar pair new-key)))
    alist)

  (defun my/minor-mode-line-limit (minor-mode line-limit)
    "Disable minor-mode if file exceeds line-limit"
    (if (> (count-lines (point-min) (point-max)) line-limit)
	(funcall minor-mode -1)
      (funcall minor-mode)))
  :init
  (setq text-mode-ispell-word-completion nil)
  ;; TAB cycle never
  (setq completion-cycle-threshold nil)
  ;; tab does indentation + complete
  (setq tab-always-indent 'complete)
  (setq indent-tabs-mode nil)
  ;; Scrolling
  (setq scroll-margin 10
        scroll-conservatively 10
        ;; aggressively doesn't get set in any buffers anyway
        scroll-preserve-screen-position t
        auto-window-vscroll nil)
  :bind
  ("M-z" . zap-up-to-char))

;; recent file list
(recentf-mode 1)

;; Persist history
(use-package savehist
  :init
  (savehist-mode))

;; Transient mark mode
;; https://emacsdocs.org/docs/emacs/Mark
(transient-mark-mode 1)
#+END_SRC

** Diagnostics

*** Spell Checking

**** Jinx

#+begin_src emacs-lisp :tangle init.el
(use-package jinx
  :ensure t
  :hook ((prog-mode-hook . jinx-mode)
         (text-mode-hook . jinx-mode)
         (conf-mode-hook . jinx-mode))
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  )
#+end_src

*** Syntax checkers

**** Flymake

#+begin_src emacs-lisp :tangle init.el
(use-package flymake
  :defer t
  :hook ((prog-mode-hook text-mode-hook) . flymake-mode)
  :config
  (setq flymake-fringe-indicator-position 'right-fringe))
#+end_src

**** Flycheck (disabled)

#+begin_src emacs-lisp :tangle no
(use-package consult-flycheck
  :ensure t
  :after (consult flycheck))

(use-package flycheck
  :ensure t
  :commands flycheck-list-errors flycheck-buffer
  :functions flycheck-redefine-standard-error-levels
  :custom
  (flycheck-indication-mode 'right-fringe)
  (flycheck-display-errors delay 0.25)
  (flycheck-idle-change-delay 1.0)
  :hook
  (first-buffer-hook . global-flycheck-mode)
  :config
  (flycheck-redefine-standard-error-levels nil 'my-flycheck-fringe-bitmap-arrow)
  :init
  (define-fringe-bitmap 'my-flycheck-fringe-bitmap-arrow [16 48 112 240 112 48 16] nil nil 'center))

;; (use-package flycheck-inline
;;   :ensure t
;;   :after flycheck
;;   :init (global-flycheck-inline-mode))

#+end_src


*** Linters

**** Cognitive Complexity

Treesitter based calculation of programming complexity.

#+begin_src emacs-lisp :tangle init.el
(use-package cognitive-complexity
  :ensure t
  :blackout
  :preface
  (defun enable-cc-line-limit ()
    (my/minor-mode-line-limit 'cognitive-complexity-mode 5000))
  :hook
  (prog-mode-hook . enable-cc-line-limit))
#+end_src


*** LSP

**** eglot

For some reason eglot-booster-mode turns on but not early enough to wrap the server
startup when doing `:before eglot` so just load it on startup.

#+begin_src emacs-lisp :tangle init.el
(use-package eglot-booster
  :ensure t
  :commands (eglot-booster-mode)
  :init
  (eglot-booster-mode))

(use-package consult-eglot
  :ensure t
  :after consult)

(use-package eglot
  :commands (eglot eglot-ensure)
  :functions eglot-completion-at-point
  :preface
  (defun my/eglot-setup-capf ()
    (setq-local completion-at-point-functions
                (append (list (cape-capf-nonexclusive
                               (cape-capf-super
                                #'eglot-completion-at-point
                                #'tempel-expand)))
                        (default-value 'completion-at-point-functions))))
  (defun my/eglot-disable-on-type-formatting ()
    (setq-local eglot-ignored-server-capabilities
                (cons :documentOnTypeFormattingProvider
                      eglot-ignored-server-capabilities)))
  :hook
  (eglot-managed-mode-hook . my/eglot-setup-capf)
  :init
  (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
  :custom
  (lsp-completion-provider :none) ; use corfu intsead for lsp completion
  :config
  (lsp-snippet-tempel-eglot-init)
  (setq eglot-autoshutdown t)
  (setq completion-category-defaults nil)
  (setq eglot-server-programs
	(my/replace-keys eglot-server-programs
			 '((nix-mode . (nix-mode nix-ts-mode))
			   (zig-mode . (zig-mode zig-ts-mode)))))
  :custom-face
  (eglot-highlight-symbol-face ((t (:underline t :weight bold)))))
#+end_src

** Org mode

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package org
    :ensure t
    :functions org-end-of-line org-at-heading-p
    :preface
    (defun my/org-prepare-expand-heading ()
      "Move point to before ellipsis, if after ellipsis."
      (when (and (not (org-at-heading-p))
                 (save-excursion
                   (org-end-of-line)
                   (org-at-heading-p)))
        (org-end-of-line)))
    :init
    (org-mode)
    :config
    (add-hook 'org-tab-first-hook #'my/org-prepare-expand-heading)
    (setq org-src-preserve-indentation t)
    (setq org-imenu-depth 4))
#+end_src

** Navigation

*** Bookmark+ (disabled)

Enhanced bookmarks [[https://www.emacswiki.org/emacs/BookmarkPlus#h5o-2][EmacsWiki]]. I would like to enable this once I have time
to set up a =Consult= function for searching bookmark+.

#+begin_src emacs-lisp :tangle no
(use-package bookmark+
  :ensure t
  :defer t)
#+end_src


*** Backtracking

**** Gumshoe

This is a point tracker using space to retrace my steps.

#+begin_src emacs-lisp :tangle init.el
(use-package gumshoe
   :ensure t
   :commands global-gumshoe-mode
   :bind
   ("M-g M-b" . gumshoe-peruse-in-buffer)
   ("M-g M-B" . gumshoe-peruse-globally)
   ("M-g b" . gumshoe-buf-backtrack)
   ("M-g B" . gumshoe-win-backtrack)
   (:map global-gumshoe-backtracking-mode-map
         ("M-{" . global-gumshoe-backtracking-mode-back)
         ("M-}" . global-gumshoe-backtracking-mode-forward))
   :init
   (global-gumshoe-mode 1))
#+end_src

**** Dogears (disabled)

Third time is the charm, a point tracker using time.

#+begin_src emacs-lisp :tangle no
(use-package dogears
  :ensure t
  :bind
  (:map global-map
        ("M-g d" . dogears-go)
        ("M-g M-b" . dogears-back)
        ("M-g M-f" . dogears-forward)
        ("M-g M-d" . dogears-list)
        ("M-g M-D" . dogears-sidebar))
  :config
  (defvar-keymap dogears-repeat-map
    :repeat t
    "f" #'dogears-forward
    "b" #'dogears-back))
#+end_src

*** isearch

#+begin_src emacs-lisp :tangle init.el
(use-package isearch
  :config
  (setq isearch-lazy-count t)
  (setq isearch-lazy-highlight t))
#+end_src

*** xref

Adds xref stack support for consult.

#+begin_src emacs-lisp :tangle init.el
(use-package consult-xref-stack
  :ensure t
  :after consult)
#+end_src

** Polymode (disabled)

#+begin_src emacs-lisp :tangle no
(use-package poly-markdown
  :ensure t
  :mode ("\\.md\\'" . poly-markdown-mode))

(use-package poly-org
  :ensure t)
#+end_src

** Terminals

*** Eshell

#+begin_src emacs-lisp :tangle init.el
(use-package eshell
  :ensure nil
  :preface
  (eval-when-compile
    (require 'em-term))
  (autoload 'eshell-write-aliases-list "em-alias")
  (autoload 'eshell/alias "em-alias")
  (autoload 'eshell-find-previous-directory "em-dirs")
  (autoload 'eshell/cd "em-dirs")
  (autoload 'ring-elements "ring")

  ;; Bash aliases from
  ;; https://emacs.stackexchange.com/questions/74385/is-there-any-way-of-making-eshell-aliases-using-bash-and-zsh-aliases-syntax
  (defun eshell-load-bash-aliases ()
    "Read Bash aliases and add them to the list of eshell aliases."
    ;; Bash needs to be run - temporarily - interactively
    ;; in order to get the list of aliases.
    (with-temp-buffer
      (call-process "bash" nil '(t nil) nil "-ci" "alias")
      (goto-char (point-min))
      (cl-letf (((symbol-function 'eshell-write-aliases-list) #'ignore))
        (while (re-search-forward "alias \\(.+\\)='\\(.+\\)'$" nil t)
          (eshell/alias (match-string 1) (format "%s $*" (match-string 2)))))
      (eshell-write-aliases-list)))

  ;; from https://karthinks.com/software/jumping-directories-in-eshell/
  (defvar consult-dir-sources)
  (defvar eshell-last-dir-ring)

  (defun init-eshell-set-visual-commands ()
    (setq eshell-visual-commands (append '("nix" "psy") eshell-visual-commands)))
  :hook
  (eshell-mode-hook . init-eshell-set-visual-commands)
  ;; We only want Bash aliases to be loaded when Eshell loads its own aliases,
  ;; rather than every time `eshell-mode' is enabled.
  (eshell-alias-load-hook . eshell-load-bash-aliases)
  :config
  (defun eshell/z (&optional regexp)
    "Navigate to a previously visited directory in eshell, or to
any directory proferred by `consult-dir'."
    (let ((eshell-dirs (delete-dups
                        (mapcar 'abbreviate-file-name
                                (ring-elements eshell-last-dir-ring)))))
      (require 'consult-dir nil 'noerror)
      (cond
       ((and (not regexp) (featurep 'consult-dir))
        (let* ((consult-dir--source-eshell `(:name "Eshell"
                                                   :narrow ?e
                                                   :category file
                                                   :face consult-file
                                                   :items ,eshell-dirs))
               (consult-dir-sources (cons consult-dir--source-eshell
                                          consult-dir-sources)))
          (eshell/cd (substring-no-properties
                      (consult-dir--pick "Switch directory: ")))))
       (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                       (completing-read "cd: " eshell-dirs))))))))

#+end_src

** Windowing

#+begin_src emacs-lisp :tangle init.el
;; undo+redo window changes
(use-package winner
  :init
  (winner-mode t))

;; avy style winodw navigation + editing
(use-package ace-window
  :ensure t
  :init
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (setq aw-dispatch-always t)
  :bind ("M-o" . ace-window))

(use-package bufler
  :ensure t
  :commands bufler-mode
  :config
  (bufler-mode))

(use-package burly
  :ensure t)
#+end_src

** Undo/redo

*** Vundo

#+begin_src emacs-lisp :tangle init.el
(use-package vundo
  :ensure t)
#+end_src

** Keybinding Help

See embark. Using embark prefix. Type `C-h` after a prefix. Then can press
`@` to use a keybinding (or do completing-read).

*** Which-Key (disabled)

#+begin_src emacs-lisp :tangle no
(use-package which-key
  :commands which-key-mode
  :functions which-key--hide-popup which-key--create-buffer-and-show
  :config
  (which-key-mode)
  :blackout)
#+end_src

** Git

#+begin_src emacs-lisp :tangle init.el
(use-package smerge-mode
  ;; builtin
  :config
  (repeatify 'smerge-basic-map))

(use-package git-timemachine
  :ensure t)

;; Forges

;; (use-package consult-gh
;;   :ensure t
;;   :after consult)

;; (use-package forge
;;  :after magit)

(use-package browse-at-remote
  :ensure t)

;; Magit
(use-package magit-delta
  :ensure t
  :hook (magit-mode-hook . magit-delta-mode))

(use-package magit
  :ensure t
  :functions magit-wip-commit-initial-backup
  :commands magit-wip-mode
  :hook
  (my/project-git-hook . (lambda () (magit-wip-mode t)))
  (before-save-hook . (lambda ()
			(when (my/project-is-git)
			  (magit-wip-commit-initial-backup)))))

;; diff highlighting

;; https://github.com/doomemacs/doomemacs/blob/98d753e1036f76551ccaa61f5c810782cda3b48a/modules/ui/vc-gutter/config.el#L34
(use-package diff-hl
  :ensure t
  :commands diff-hl-stage-current-hunk diff-hl-revert-hunk diff-hl-next-hunk diff-hl-previous-hunk
  :custom
  (vc-git-diff-switches '("--histogram"))
  :preface
  (defun my/diff-hl-define-thin-bitmaps (&rest _)
    (define-fringe-bitmap 'diff-hl-bmp-middle [240] nil nil '(center repeated))
    (define-fringe-bitmap 'diff-hl-bmp-delete [240 240 224 224 192 192 128 128] nil nil 'top))
  (defun my/diff-hl-type-face-fn (type _pos)
    (intern (format "diff-hl-%s" type)))
  (defun my/diff-hl-type-at-pos-fn (type _pos)
    (if (eq type 'delete)
        'diff-hl-bmp-delete
      'diff-hl-bmp-middle))
  (defun my/diff-hl-fix-modus ()
    (modus-themes-with-colors
      (face-spec-set 'diff-hl-change `((t :foreground ,bg-changed-fringe :background unspecified)))
      (face-spec-set 'diff-hl-delete `((t :foreground ,bg-removed-fringe :background unspecified)))
      (face-spec-set 'diff-hl-insert `((t :foreground ,bg-added-fringe :background unspecified)))))
  :hook
  (find-file-hook . diff-hl-mode)
  (vc-dir-mode-hook . diff-hl-dir-mode)
  (dired-mode-hook . diff-hl-dired-mode)
  (magit-post-refresh-hook . diff-hl-magit-post-refresh)
  (magit-pre-refresh-hook . diff-hl-magit-pre-refresh)
  (diff-hl-mode-hook . diff-hl-flydiff-mode)
  (diff-hl-mode-hook . my/diff-hl-fix-modus)
  (modus-themes-after-load-theme-hook . my/diff-hl-fix-modus)
  :init
  (advice-add 'diff-hl-define-bitmaps :override #'my/diff-hl-define-thin-bitmaps)
  (advice-add 'diff-hl-fringe-bmp-from-pos :override #'my/diff-hl-type-at-pos-fn)
  (advice-add 'diff-hl-fringe-bmp-from-type :override #'my/diff-hl-type-at-pos-fn)
  :config
  (repeatify 'diff-hl-command-map))

(if (fboundp 'fringe-mode) (fringe-mode '8))
(setq-default fringes-outside-margins t)

#+end_src

** Uncategorized

#+begin_src emacs-lisp :tangle init.el
;; TODO: monaspace neon is missing the o symbol, so when we get fallback font in the
;; minibuffer it is slightly the wrong size and causes prompt to move
;; use (font-family-list) to see available fonts

;; UI

;; Line numbers
(require 'display-line-numbers)
(setq display-line-numbers-type 'relative)
(setq display-line-numbers-current-absolute t)
(global-display-line-numbers-mode)

(put 'narrow-to-region 'disabled nil)

;; fill column

(setq-default fill-column 80)
(dolist (hook '(prog-mode-hook
                text-mode-hook))
  (add-hook hook #'display-fill-column-indicator-mode t))

;; Icons

;; Whitespace
(dolist (hook '(prog-mode-hook
                text-mode-hook))
  (add-hook hook (lambda () (setq-local show-trailing-whitespace t))))

(use-package whitespace-cleanup-mode
  :ensure t
  :commands global-whitespace-cleanup-mode
  :init
  (global-whitespace-cleanup-mode))
#+end_src

#+begin_src emacs-lisp :tangle init.el
;; Operate on grep buffer

(use-package wgrep
  :ensure t)

;; Dired

(use-package wdired)

(use-package diredfl
  :ensure t
  :commands diredfl-global-mode
  :init
  (diredfl-global-mode))

;; Keymap Actions

(use-package embark
  :ensure t
  :bind (("C-." . embark-act)         ;; pick some comfortable binding
         ("C-;" . embark-dwim)        ;; good alternative: M-.
         ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings
  :commands embark-prefix-help-command
  :init
  ;; Unset help-for-help on C-h C-h so we can instead use prefix help.
  ;; Can still access help-for-help with C-h ?
  (global-unset-key (kbd "C-h C-h"))
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

(use-package embark-consult
  :ensure t
  :after (embark consult)
  :hook
  ;; if you want to have consult previews as you move around
  ;; an auto-updating embark collect buffer
  (embark-collect-mode-hook . consult-preview-at-point-mode))


;; Completion style

(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless partial-completion basic))
  (setq completion-category-defaults nil)
  (setq completion-category-overrides '((file (styles partial-completion)))))

;; Snippets

(use-package tempel
  :ensure t
  :commands tempel-expand
  :preface
  (defun my/tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions`
    (add-hook 'completion-at-point-functions
               #'tempel-expand t t))
  :init
  (add-hook 'conf-mode-hook 'my/tempel-setup-capf)
  (add-hook 'prog-mode-hook 'my/tempel-setup-capf)
  (add-hook 'text-mode-hook 'my/tempel-setup-capf))

(use-package lsp-snippet-tempel
  :ensure t
  :commands lsp-snippet-tempel-eglot-init)

;; Completion at point functions + capf UI

;; https://kristofferbalintona.me/posts/202203130102/
(use-package cape
  :ensure t
  :bind ("C-c p p" . completion-at-point) ;; capf
  ("C-c p t" . complete-tag)              ;; etags
  ("C-c p d" . cape-dabbrev)              ;; or dabbrev-completion
  ("C-c p h" . cape-history)
  ("C-c p f" . cape-file)
  ("C-c p k" . cape-keyword)
  ("C-c p s" . cape-elisp-symbol)
  ("C-c p e" . cape-elisp-block)
  ("C-c p a" . cape-abbrev)
  ("C-c p l" . cape-line)
  ("C-c p w" . cape-dict)
  ("C-c p :" . cape-emoji)
  ("C-c p \\" . cape-tex)
  ("C-c p _" . cape-tex)
  ("C-c p ^" . cape-tex)
  ("C-c p &" . cape-sgml)
  ("C-c p r" . cape-rfc1345)
  :init
  (add-hook 'completion-at-point-functions (cape-capf-nonexclusive #'cape-dabbrev) nil nil)
  (add-hook 'completion-at-point-functions (cape-capf-nonexclusive #'cape-file) nil nil)
  (add-hook 'completion-at-point-functions (cape-capf-nonexclusive #'cape-elisp-block) nil nil)
  :commands cape-wrap-buster cape-capf-super cape-capf-nonexclusive
  :defines cape-file-directory-must-exit
  :config
  ;; https://old.reddit.com/r/emacs/comments/19b8a83/capefile_fails_when_called_as_a_capf_but_works/
  (setq cape-file-directory-must-exit nil))
#+end_src

**** Completion in region

#+begin_src emacs-lisp :tangle init.el
(use-package corfu
  :ensure t
  :commands (corfu-mode global-corfu-mode)
  :preface
  (defun corfu-send-shell (&rest _)
    "Send completion candidate when inside comint/eshell."
    (cond
     ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
      (eshell-send-input))
     ((and (derived-mode-p 'comint-mode)  (fboundp 'comint-send-input))
      (comint-send-input))))
  :custom
  (corfu-cycle t)
  (corfu-preselect 'valid)
  (corfu-quit-no-match 'separator)
  (corfu-auto t)
  (corfu-min-width 60)
  (corfu-max-width corfu-min-width)
  (corfu-count 14)
  (corfu-scroll-margin 4)
  (corfu-echo-mode nil) ; Using corfu-popupinfo
  (corfu-popupinfo-delay '(0.2 . 1.0))
  :bind
  (:map corfu-map ;; use TAB for cycling, default is `corfu-complete`
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
        ;; configure M-SPC for seprator insertion
        ("M-SPC" . corfu-insert-separator)
        ("S-<return>" . corfu-insert)
        ("RET" . nil) ;; leave enter alone
        )
  :hook
  (corfu-mode-hook . corfu-popupinfo-mode)
  :config
  (add-hook 'eshell-mode-hook (lambda ()
                                (setq-local corfu-auto nil)
                                (corfu-mode)))
  (advice-add #'corfu-insert :after #'corfu-send-shell)
  :init
  (global-corfu-mode 1))


(use-package kind-icon
  :ensure t
  :after corfu
  :custom
  (kind-icon-use-icons t)
  (kind-icon-default-face 'corfu-default)
  (kind-icon-blend-background nil)
  (kind-icon-blend-frac 0.08)
  ;;(svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache"))
  :functions kind-icon-reset-cache kind-icon-margin-formatter
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
  (add-hook 'my/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))
#+end_src

Consult/vertico/marginalia

#+begin_src emacs-lisp :tangle init.el
;; minibuffer

(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
  :commands marginalia-mode
  :init
  (marginalia-mode))

(use-package vertico
  :ensure t
  :defines vertico-multiform-categories
  :init
  (setq embark-indicators
        '(embark-minimal-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  :hook
  (after-init-hook . vertico-mode)
  :custom
  (vertico-multiform-mode t)
  (vertico-cycle t)
  (vertico-reverse-mode t)
  (vertico-resize t)
  :config
  (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))
  )

;; Example configuration for Consult
(use-package consult
  :ensure t
  :defer 2
  :preface
  (autoload 'consult-xref "consult-xref")
  :functions consult-register-window consult-register-format
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c K" . consult-kmacro) ;; C-c k is used by meow
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x C-d" . consult-dir)
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("M-g l" . consult-eglot-symbols)
	 ("M-g ," . consult-xref-stack-backward)
	 ("M-g M-," . consult-xref-stack-forward)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-fd)                  ;; Alternative: consult-find
         ("M-s c" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file)
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element
  ;; The :init configuration is always executed (Not lazy)
  :init
  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)
  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)
  ;; Use Consult to select xref locations with preview
  (eval-when-compile (require 'xref))
  (with-eval-after-load 'xref
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref))
  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config
  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; "C-+"
  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
            ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
            ;;;; 2. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
            ;;;; 3. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
            ;;;; 4. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
            ;;;; 5. No project support
  ;; (setq consult-project-function nil)
  )

(use-package consult-todo
  :ensure t
  :after (consult hl-todo))

(use-package consult-dir
  :ensure t
  :functions consult-dir--pick
  :after consult)

#+end_src

** Editing

*** Delete Select (disabled)

Builtin package for deleting selection when typing.

#+begin_src emacs-lisp
(use-package delsel
  :ensure nil
  :hook (after-init-hook . delete-selection-mode))
#+end_src

*** Backup

#+begin_src emacs-lisp :tangle init.el
(let ((backup-dir (expand-file-name "backups/" user-emacs-directory)))
  (make-directory backup-dir t)
  (setq backup-directory-alist `(("." . ,backup-dir))))
(setq backup-by-copying t)
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq version-control t)
(setq vc-make-backup-files t)
#+end_src

*** Autosave

#+begin_src emacs-lisp :tangle init.el
(let ((auto-save-dir (expand-file-name "autosaves/" user-emacs-directory)))
  (make-directory auto-save-dir t)
  (setq auto-save-file-name-transforms `((".*" ,auto-save-dir))))
#+end_src

** Motions

*** Avy

#+begin_src emacs-lisp :tangle init.el
(use-package avy
  :ensure t
  :bind
  ("C-:" . avy-goto-char))
#+end_src

** Visuals

*** Fonts

#+begin_src emacs-lisp :tangle init.el
(let ((mono-spaced-font "Berkeley Mono Variable")
      (proportionately-spaced-font "DejaVu Sans"))
  (set-face-attribute 'default nil :family mono-spaced-font :height 100  :weight 'normal)
  (set-face-attribute 'fixed-pitch nil :family mono-spaced-font :height 1.0 :weight 'normal)
  (set-face-attribute 'variable-pitch nil :family proportionately-spaced-font :height 1.0 :weight 'normal))

(defun set-bigger-spacing ()
  (setq-local default-text-properties '(line-spacing 0.05)))
(dolist (hook '(text-mode-hook prog-mode-hook)) (add-hook hook 'set-bigger-spacing))
#+end_src

*** Breadcrumbs

#+begin_src emacs-lisp :tangle init.el
(use-package breadcrumb
  :ensure t
  :hook (first-buffer-hook . breadcrumb-mode))
#+end_src

*** Icons

**** Nerd Icons

#+begin_src emacs-lisp :tangle init.el
(use-package nerd-icons
  :ensure t
  :require t
  :custom
  (nerd-icons-font-family "Symbols Nerd Font Mono"))

(use-package nerd-icons-dired
  :ensure t
  :hook
  (dired-mode-hook . nerd-icons-dired-mode))

(use-package nerd-icons-completion
  :ensure t
  :commands nerd-icons-completion-mode
  :hook
  (marginalia-mode-hook . nerd-icons-completion-marginalia-setup)
  :init
  (with-eval-after-load 'marginalia
    (nerd-icons-completion-mode)))
#+end_src

**** all-the-icons (disabled)

#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :commands (all-the-icons-faicon all-the-icons-octicon))

(use-package all-the-icons-dired
  :ensure t
  :hook (dired-mode-hook . all-the-icons-dired-mode))

(use-package all-the-icons-completion
  :ensure t
  :hook (marginalia-mode-hook . all-the-icons-completion-marginalia-setup))
#+end_src


** Documentation

*** Devdocs

Devdocs lets you download documentation.

#+begin_src emacs-lisp :tangle init.el
(use-package devdocs
  :ensure t)
#+end_src

*** TLDR

#+begin_src emacs-lisp :tangle init.el
(use-package tldr
  :ensure t
  :custom
  ;; tldr unzips to tldr-main/ while tldr.el expects tldr/
  (tldr-directory-path (expand-file-name "tldr-main/" user-emacs-directory)))
#+end_src

** Projects

Configurations for project specific setup.

*** project.el

Add a nix-project-finder. Need to make sure it is before the vc project finder.
breadcrumb-mode calls project-current, and the vc project finder has horrific
performance in the `/nix/store` directory. Profiler had it at 50%. So the function
is useful and good for performance.

#+begin_src emacs-lisp :tangle init.el
(use-package project
  :preface
  ;; A subdirectory of /nix/store
  (defun my/nix-project-finder (dir)
    (let ((nix-store-prefix "/nix/store/")
          (dirs (split-string (expand-file-name dir) "/")))
      (when (and (> (length dirs) 3)
                 (string-prefix-p nix-store-prefix dir))
        (cons 'transient (mapconcat 'identity (seq-take dirs 4) "/")))))
  (defun my/project-is-git ()
    "Check if current project is git-based."
    (when-let* ((project (project-current)))
      (and (eq 'vc (car project))
           (eq 'Git (cadr project)))))
  (defun my/run-project-git-hook ()
    (when (my/project-is-git)
      (run-hooks 'my/project-git-hook)))
  :config
  ;; Load magit first so we get ctrl+x p p m
  (require 'magit-extras)
  (add-hook 'project-find-functions 'my/nix-project-finder)
  (add-hook 'find-file-hook 'my/run-project-git-hook))
#+end_src

*** Direnv

Use basic envrc, but investigate hacks from [[https://github.com/doomemacs/doomemacs/blob/98d753e1036f76551ccaa61f5c810782cda3b48a/modules/tools/direnv/config.el#L27][doom]].

Magit WIP mode sets the ~GIT_INDEX_FILE~ environment variable (using the
~magit-with-temp-index~ macro). If WIP mode is the first to create the magit
process buffer, the buffer is created with the environment variable set, and
thus results in a cache miss to direnv. Because we know what is being set,
remove the environment variable for `envrc--update` so we don't get a cache miss
and an unnecessary direnv reload.

#+begin_src emacs-lisp :tangle init.el
(use-package envrc
  :ensure t
  :functions envrc--find-env-dir
  :hook
  (after-init-hook . envrc-global-mode)
  :preface
  (defun my/envrc-remove-magit-env (orig-fun &rest args)
    (let ((old-process-env (default-value 'process-environment)))
      (setq-default process-environment
	    (let ((first-env (car old-process-env)))
	      (if (and first-env
		       (string-match "^GIT_INDEX_FILE=\\(.*\\)" first-env)
		       (let ((magit-dir (expand-file-name ".git/index.magit" (envrc--find-env-dir)))
			     (git-index-file (match-string 1 first-env)))
			 (string-prefix-p magit-dir git-index-file)))
		  (cdr old-process-env)
		old-process-env)))
      (unwind-protect
	  (apply orig-fun args)
	(setq-default process-environment old-process-env))))
  :init
  (advice-add 'envrc--update :around #'my/envrc-remove-magit-env))
#+end_src

*** Editor Config

Integrate with editorconfig standard

#+begin_src emacs-lisp :tangle init.el
(use-package editorconfig
  :ensure t
  :hook (first-buffer-hook . editorconfig-mode)
  :blackout)
#+end_src

** Debug

*** dape

Debug adapter client

#+begin_src emacs-lisp :tangle init.el
(use-package dape
  :ensure t
  :functions dape-breakpoint-global-mode
  :hook
  ((kill-emacs . dape-breakpoint-save)
   (after-init . dape-breakpoint-load))
  :config
  (setq dape-buffer-window-arrangement 'right)
  (dape-breakpoint-global-mode))
#+end_src

** Language configs

*** Python

#+begin_src emacs-lisp :tangle init.el
(use-package python
  :mode ("\\.py\\'" . python-ts-mode)
  :hook (python-ts-mode-hook . eglot-ensure)
  :bind (:map python-ts-mode-map
	      ("C-c l t" . python-pytest-dispatch))
  :config
  (require 'python-pytest))

(use-package python-pytest
  :ensure t
  :init
  (setq python-pytest-preferred-project-manager 'project))
#+end_src

*** Nix

#+begin_src emacs-lisp :tangle init.el
(use-package nix-ts-mode
  :ensure t
  :mode "\\.nix\\'"
  :hook (nix-ts-mode-hook . eglot-ensure))
#+end_src

*** C/C++

#+begin_src emacs-lisp :tangle init.el
(use-package c-ts-mode
  :defines c-ts-mode-map c++-ts-mode-map
  :init
  (add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
  (add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
  (add-to-list 'major-mode-remap-alist '(c-or-c++-mode . c-or-c++-ts-mode))
  :hook
  (c-ts-mode-hook . eglot-ensure)
  (c-ts-mode-hook . my/disable-indent-tabs)
  (c-ts-mode-hook . my/eglot-disable-on-type-formatting)
  (c++-ts-mode-hook . eglot-ensure)
  (c++-ts-mode-hook . my/disable-indent-tabs)
  (c++-ts-mode-hook . my/eglot-disable-on-type-formatting))
#+end_src

*** Zig

#+begin_src emacs-lisp :tangle init.el
(use-package zig-ts-mode
  :ensure t
  :mode "\\.zig\\'"
  :hook (zig-ts-mode-hook . eglot-ensure))
#+end_src

*** Golang

Use https://github.com/dominikh/go-mode.el. There is a
supposed re-write with treesitter coming.

#+begin_src emacs-lisp :tangle init.el
(use-package go-mode
  :ensure t
  :hook (go-mode-hook . eglot-ensure))
#+end_src

*** Rust

Using the emacs-rustic fork.

#+begin_src emacs-lisp :tangle init.el
(use-package rust-mode
  :ensure t
  :init
  (setq rust-mode-treesitter-derive t))

(use-package rustic
  :ensure t
  :after (rust-mode)
  :init
  (remove-hook 'rustic-mode-hook 'flycheck-mode)
  :custom
  (rustic-lsp-client 'eglot))
#+end_src

*** Shell mode

#+begin_src emacs-lisp :tangle init.el
(use-package sh-script
  :hook
  (sh-mode-hook . eglot-ensure)
  (bash-ts-mode-hook . eglot-ensure))
#+end_src

** General programming

*** Code folding

Code folding using treesitter.

#+begin_src emacs-lisp :tangle init.el
(use-package treesit-fold
  :ensure t
  :hook (first-buffer-hook . global-treesit-fold-mode))
#+end_src

*** Compilation mode

Disabling line length fixes the annoying ~[...]~ in the compilation prompt.

#+begin_src emacs-lisp :tangle init.el
(setq compilation-scroll-output t)
(setq compilation-auto-jump-to-first-error t)
(setq compilation-max-output-line-length nil)
(setq compilation-ask-about-save t)
#+end_src

*** Uncategorized

#+begin_src emacs-lisp :tangle init.el
;; Hook LSP and custom functions into apheleia formatting
;; https://github.com/radian-software/apheleia/issues/153
;;
;; (defun my/lsp-go-save-hooks ()
;;  (add-hook 'before-save-hook #'lsp-format-buffer t t)
;;  (add-hook 'before-save-hook #'lsp-organize-imports t t))

(use-package apheleia
  :ensure t
  :hook ((go-ts-mode-hook . apheleia-mode)
         (python-ts-mode-hook . apheleia-mode)
         (bash-ts-mode-hook . apheleia-mode)
         (sh-mode-hook . apheleia-mode)
         (rust-mode-hook . apheleia-mode)
         (zig-ts-mode-hook . apheleia-mode)
         (nix-ts-mode-hook . apheleia-mode))
  :blackout " Fmt"
  :config
  (setf (alist-get 'python-ts-mode apheleia-mode-alist) '(ruff)
        (alist-get 'rust-ts-mode apheleia-mode-alist) '(rustfmt)
        (alist-get 'sh-mode apheleia-mode-alist) '(shfmt)
        (alist-get 'bash-ts-mode apheleia-mode-alist) '(shfmt)
        (alist-get 'nix-ts-mode apheleia-mode-alist) '(nixfmt))
  )

;; singlestore
(setq-default compile-command "memsql-please make debug") ; set default command for M-x compile
(setq-default gdb-create-source-file-list nil)  ; gdb initialization takes a long time without this
(setq-default word-wrap t)                      ; wrap long lines at word boundaries for better readability

;; Adjust C++ style to more closely match the style we use in the MemSQL codebase

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode)) ; use c++-mode instead of c-mode for .h files

;; Default settings for sql-mysql
;; You can run a mysql/memsql client in Emacs with M-x sql-mysql

(defvar sql-user)
(defvar sql-password)
(defvar sql-server)
(setq sql-user "root")
(setq sql-password "")
(setq sql-server "127.0.0.1")
#+end_src

** Activity watch

#+begin_src emacs-lisp :tangle init.el
(use-package activity-watch-mode
  :ensure t
  :hook
  (first-file-hook . global-activity-watch-mode))
#+end_src
