#+TITLE: EmacsConfig
#+AUTHOR: Jordan Isaacs

* early-init.el

#+begin_src emacs-lisp :tangle early-init.el
;;; early-init.el --- Early Initialization -*- lexical-binding: t; -*-
#+end_src

** Startup
Time the startup

#+begin_src emacs-lisp :tangle early-init.el
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "loaded Emacs in %0.03fs"
                     (float-time (time-subtract after-init-time before-init-time)))))
#+end_src

Lower GC for init

#+begin_src emacs-lisp :tangle early-init.el
(let ((normal-gc-cons-threshold gc-cons-threshold)
      (normal-gc-cons-percentage gc-cons-percentage)
      (normal-file-name-handler-alist file-name-handler-alist)
      (init-gc-cons-threshold most-positive-fixnum)
      (init-gc-cons-percentage 0.6))
  (setq gc-cons-threshold init-gc-cons-threshold
        gc-cons-percentage init-gc-cons-percentage
        file-name-handler-alist nil)
  (add-hook 'after-init-hook
            `(lambda ()
               (setq gc-cons-threshold ,normal-gc-cons-threshold
                     gc-cons-percentage ,normal-gc-cons-percentage
                     file-name-handler-alist ',normal-file-name-handler-alist))))
#+end_src

Redirect calls to `user-emacs-directory` to `$XDG_DATA_DIR` if not one of our
specified paths. Since we are using `--init-directory NIX_STORE` which is read only.

#+begin_src emacs-lisp :tangle early-init.el
(startup-redirect-eln-cache (expand-file-name "eln-cache/" user-emacs-directory))
(setq user-emacs-directory (concat (getenv "XDG_STATE_HOME") "/emacs"))
#+end_src

Performance tweaks. Don't load default library and use fundamental-mode to reduce
number of hooks.

#+begin_src emacs-lisp :tangle early-init.el
(setq inhibit-default-init t)
(setq initial-major-mode 'fundamental-mode)
#+end_src

#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

Inhibit startup screen and messages.

#+begin_src emacs-lisp :tangle early-init.el
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)

(setq use-dialog-box nil)
(push '(undecorated . t) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)

(setq frame-inhibit-implied-resize t)
(defvar global-text-scale-adjust-resizes-frames t)
(push '(drag-internal-border . t) default-frame-alist)
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src

Lazy load hooks

#+begin_src emacs-lisp :tangle early-init.el
(defun run-hook-on (hook-var trigger-hooks)
  "Configure HOOK-VAR to be invoked exactly once when any of the TRIGGER-HOOKS
  are invoked *after* Emacs has initialized (to reduce false positives). Once
  HOOK-VAR is triggered, it is reset to nil.

  HOOK-VAR is a quoted hook.
  TRIGGER-HOOK is a list of quoted hooks and/or sharp-quoted functions."
  (dolist (hook trigger-hooks)
    (let ((fn (make-symbol (format "chain-%s-to-%s-h" hook-var hook)))
          running)
      (fset
       fn (lambda (&rest _)
            ;; Only trigger this after Emacs has initialized.
            (when (and after-init-time
                       (not running)
                       (boundp hook)
                       (symbol-value hook))
              ;; prevent infinite recursion
              (setq running t)
              ;; (setq hook-run-state (cons (cons hook-var t) hook-run-state))
              (run-hooks hook-var)
              (set hook-var nil))))
      (cond
       ((eq hook 'find-file-hook)
        ;; Advise `after-find-file' instead of using `find-file-hook'
        ;; because the latter is triggered too late (after the file has
        ;; opened and modes are all set up).
        (advice-add 'after-find-file :before fn '((depth . -101))))
       ((add-hook hook fn -101)))
      fn)))

(defvar first-input-hook ()
  "Transient hooks run before the first user input.")

(defvar first-file-hook ()
  "Transient hooks run before the first interactively opened file.")

(defvar first-buffer-hook ()
  "Transient hooks run before the first interactively opened buffer.")

(run-hook-on 'first-buffer-hook '(find-file-hook window-buffer-change-functions))
(run-hook-on 'first-file-hook '(find-file-hook dired-initial-position-hook))
(run-hook-on 'first-input-hook '(pre-command-hook))
#+end_src

** Stricter security

Emacs is essentially one huge security vulnerability, what with all the
dependencies it pulls in from all corners of the globe. Let's try to be a
*little* more discerning.

#+begin_src emacs-lisp :tangle early-init.el
(defvar gnutls-verify-error)
(defvar gnutls-algorithm-priority)
(defvar gnutls-min-prime-bits)
(defvar tls-checktrust)
(defvar tls-program)
(setq gnutls-verify-error noninteractive
      gnutls-algorithm-priority
      (when (boundp 'libgnutls-version)
        "SECURE128:+SECURE192:-VERS-ALL:+VERS-TLS1.3")
      ;; `gnutls-min-prime-bits' is set based on recommendations from
      ;; https://www.keylength.com/en/4/
      gnutls-min-prime-bits 3072
      tls-checktrust gnutls-verify-error
      ;; Emacs is built with gnutls.el by default, so `tls-program' won't
      ;; typically be used, but in the odd case that it does, we ensure a more
      ;; secure default for it (falling back to `openssl' if absolutely
      ;; necessary). See https://redd.it/8sykl1 for details.
      tls-program '("openssl s_client -connect %h:%p -CAfile %t -nbio -no_ssl3 -no_tls1 -no_tls1_1 -ign_eof"
                    "gnutls-cli -p %p --dh-bits=3072 --ocsp --x509cafile=%t \
  --strict-tofu --priority='SECURE192:+SECURE128:-VERS-ALL:+VERS-TLS1.2:+VERS-TLS1.3' %h"
                    ;; compatibility fallbacks
                    "gnutls-cli -p %p %h"))

#+end_src

* init.el

** Plumbing

*** Lexical bindings

#+begin_src emacs-lisp :tangle init.el
;;; -*- lexical-binding: t; -*-
#+end_src

*** Cleanup site-startup.el

Nix's site-startup.el adds `$NIX_PROFILES` paths to a variety of variables.
This is good for some variables, but not good for loading. Those paths are
mutable -- not reproducible. This fixes some weird shit that was happening
with font faces.

#+begin_src emacs-lisp :tangle init.el
(require 'cl-extra)
(require 'cl-lib)

(defun filter-nix-store (paths)
  (cl-remove-if-not
   (lambda (s)
     (string-prefix-p "/nix/store/" s))
   paths))


(setq native-comp-eln-load-path (filter-nix-store native-comp-eln-load-path))
(setq load-path (filter-nix-store load-path))
#+end_src

*** debug


#+begin_src emacs-lisp :tangle init.el
(eval-and-compile
  (when (getenv "DEBUG") (setq init-file-debug t))
  (setq debug-on-error (and (not noninteractive) init-file-debug)))
#+end_src

*** use-package

#+begin_src emacs-lisp :tangle init.el
(eval-when-compile
  (require 'use-package))

(eval-and-compile
  (defun use-package-ensure-ignore (&rest _args) t)
  (setq use-package-ensure-function #'use-package-ensure-ignore)
  (setq use-package-always-defer t)
  (setq use-package-hook-name-suffix nil))

(if init-file-debug
    (progn
      (setq use-package-verbose t
            use-package-expand-minimally nil
            use-package-compute-statistics t
            debug-on-error t))
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+end_src


#+begin_src emacs-lisp :tangle init.el
(use-package bind-key
  :ensure t)

(use-package blackout
  :ensure t
  :functions blackout)

;; TODO: monaspace neon is missing the o symbol, so when we get fallback font in the
;; minibuffer it is slightly the wrong size and causes prompt to move
;; use (font-family-list) to see available fonts
(set-face-attribute 'default nil :family "MonaspiceNe Nerd Font Mono" :height 100 :weight 'normal)

(defun set-bigger-spacing ()
  (setq-local default-text-properties '(line-spacing 0.25)))
(dolist (hook '(text-mode-hook prog-mode-hook)) (add-hook hook 'set-bigger-spacing))

;; UI

;; Line numbers
(require 'display-line-numbers)
(setq display-line-numbers-type 'relative)
(setq display-line-numbers-current-absolute t)
(global-display-line-numbers-mode)

(put 'narrow-to-region 'disabled nil)

;; fill column

(setq-default fill-column 80)
(dolist (hook '(prog-mode-hook
                text-mode-hook))
  (add-hook hook #'display-fill-column-indicator-mode t))

;; Icons

(use-package all-the-icons
  :ensure t
  :commands (all-the-icons-faicon all-the-icons-octicon))

(use-package all-the-icons-dired
  :ensure t
  :hook (dired-mode-hook . all-the-icons-dired-mode))

(use-package all-the-icons-completion
  :ensure t
  :hook (marginalia-mode-hook . all-the-icons-completion-marginalia-setup))

;; Whitespace
(dolist (hook '(prog-mode-hook
                text-mode-hook))
  (add-hook hook (lambda () (setq-local show-trailing-whitespace t))))

(use-package whitespace-cleanup-mode
  :ensure t
  :commands global-whitespace-cleanup-mode
  :init
  (global-whitespace-cleanup-mode))

;; Backups

;; TODO: backup on save versioned
(setq backup-directory-alist '(("." . "~/.emacs.d/backup/per-save")))

;; TODO: autosave

#+end_src

** Repeat mode

#+begin_src  emacs-lisp :tangle init.el

(use-package repeat
  ;; builtin
  :functions repeat--command-property
  :preface
  ;; https://old.reddit.com/r/emacs/comments/1adwnse/repeatmode_is_awesome_share_you_useful_configs/kk9vpif/
  (defun repeatify (repeat-keymap)
  "Set the `repeat-map' property on all commands bound in REPEAT-MAP."
  (named-let process ((keymap (symbol-value repeat-keymap)))
    (map-keymap
     (lambda (_key cmd)
       (cond
        ((symbolp cmd) (put cmd 'repeat-map repeat-keymap))
        ((keymapp cmd) (process cmd))))
     keymap)))

  :config
  (setq repeat-echo-function #'ignore)
  :init
  ;; This means that using alt+x will still let us use repeat mode
  (setq repeat-check-key nil)
  (repeat-mode t))

(use-package repeat-help
  :ensure t
  :defer t
  :init
  (setq repeat-help-popup-type 'embark)
  :hook (repeat-mode-hook . repeat-help-mode))
#+end_src

** Theming

#+begin_src emacs-lisp :tangle init.el
;; Tabs

;; Todo highlighting
(use-package hl-todo
  :ensure t
  :commands (hl-todo-insert hl-todo-occur)
  :functions hl-todo-next hl-todo-previous
  :custom
  (hl-todo-highlight-punctuation ":")
  (hl-todo-keyword-faces nil)
  :init
  (defvar-keymap hl-todo-repeat-map
    :repeat (:enter (hl-todo-insert) :exit (hl-todo-occur))
    "n" #'hl-todo-next
    "p" #'hl-todo-previous
    "o" #'hl-todo-occur)
  :config
  (keymap-set hl-todo-mode-map "C-c t p" #'hl-todo-previous)
  (keymap-set hl-todo-mode-map "C-c t n" #'hl-todo-next)
  (keymap-set hl-todo-mode-map "C-c t o" #'hl-todo-occur)
  (keymap-set hl-todo-mode-map "C-c t i" #'hl-todo-insert)
  :hook
  (prog-mode-hook . hl-todo-mode)
  (text-mode-hook . hl-todo-mode))

;; TODO: test
(use-package modus-themes
  :ensure t
  :after hl-todo
  :commands modus-themes-load-theme
  :preface
  (autoload 'modus-themes--retrieve-palette-value "modus-themes")
  (autoload 'modus-themes--current-theme-palette "modus-themes")
  (defun modus-themes-modify ()
    (modus-themes-with-colors
      (custom-set-faces
       `(diff-hl-change ((,c :foreground ,bg-changed-fringe)))
       `(diff-hl-delete ((,c :foreground ,bg-removed-fringe)))
       `(diff-hl-insert ((,c :foreground ,bg-added-fringe))))
      (add-to-list 'hl-todo-keyword-faces (cons "UNDONE" err))))
  :init
  (add-hook 'modus-themes-after-load-theme-hook #'modus-themes-modify)
  (modus-themes-load-theme 'modus-operandi))

#+end_src

*** Emacs

#+begin_src emacs-lisp :tangle init.el

(use-package emacs
  :init
  (setq text-mode-ispell-word-completion nil)
  ;; TAB cycle never
  (setq completion-cycle-threshold nil)
  ;; tab does indentation + complete
  (setq tab-always-indent 'complete)
  ;; Scrolling
  (setq scroll-margin 10
        scroll-conservatively 10
        ;; aggressively doesn't get set in any buffers anyway
        scroll-preserve-screen-position t
        auto-window-vscroll nil)
  :bind
  ("M-z" . zap-up-to-char))

;; recent file list
(recentf-mode 1)

;; Persist history
(use-package savehist
  :init
  (savehist-mode))

;; Transient mark mode
;; https://emacsdocs.org/docs/emacs/Mark
(transient-mark-mode 1)

;; spell checking
(use-package jinx
  :ensure t
  :hook ((prog-mode-hook . jinx-mode)
         (text-mode-hook . jinx-mode)
         (conf-mode-hook . jinx-mode))
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  )

#+END_SRC

** Org mode

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package org
    :ensure t
    :functions org-end-of-line org-at-heading-p
    :preface
    (defun my/org-prepare-expand-heading ()
      "Move point to before ellipsis, if after ellipsis."
      (when (and (not (org-at-heading-p))
                 (save-excursion
                   (org-end-of-line)
                   (org-at-heading-p)))
        (org-end-of-line)))
    :init
    (org-mode)
    :config
    (add-hook 'org-tab-first-hook #'my/org-prepare-expand-heading)
    (setq org-src-preserve-indentation t))
#+end_src

** Navigation

*** Bookmark+ (disabled)

Enhanced bookmarks [[https://www.emacswiki.org/emacs/BookmarkPlus#h5o-2][EmacsWiki]]. I would like to enable this once I have time
to set up a =Consult= function for searching bookmark+.

#+begin_src emacs-lisp :tangle no
(use-package bookmark+
  :ensure t
  :defer t)
#+end_src


*** Backtracking

**** Gumshoe

This is a point tracker using space to retrace my steps.

#+begin_src emacs-lisp :tangle init.el
(use-package gumshoe
   :ensure t
   :commands global-gumshoe-mode
   :bind
   ("M-g M-b" . gumshoe-peruse-in-buffer)
   ("M-g M-B" . gumshoe-peruse-globally)
   ("M-g b" . gumshoe-buf-backtrack)
   ("M-g B" . gumshoe-win-backtrack)
   (:map global-gumshoe-backtracking-mode-map
         ("M-r" . global-gumshoe-backtracking-mode-back)
         ("M-s" . global-gumshoe-backtracking-mode-forward))
   :init
   (global-gumshoe-mode 1))
#+end_src

**** Dogears (disabled)

Third time is the charm, a point tracker using time.

#+begin_src emacs-lisp :tangle no
(use-package dogears
  :ensure t
  :bind
  (:map global-map
        ("M-g d" . dogears-go)
        ("M-g M-b" . dogears-back)
        ("M-g M-f" . dogears-forward)
        ("M-g M-d" . dogears-list)
        ("M-g M-D" . dogears-sidebar))
  :config
  (defvar-keymap dogears-repeat-map
    :repeat t
    "f" #'dogears-forward
    "b" #'dogears-back))
#+end_src

*** isearch

#+begin_src emacs-lisp :tangle init.el
(use-package isearch
  :config
  (setq isearch-lazy-count t)
  (setq isearch-lazy-highlight t))
#+end_src


** Polymode (disabled)

#+begin_src emacs-lisp :tangle no
(use-package poly-markdown
  :ensure t
  :mode ("\\.md\\'" . poly-markdown-mode))

(use-package poly-org
  :ensure t)
#+end_src

** Eshell

#+begin_src emacs-lisp :tangle init.el
(use-package eshell
  :ensure nil
  :preface
  (eval-when-compile
    (require 'em-term))
  (autoload 'eshell-write-aliases-list "em-alias")
  (autoload 'eshell/alias "em-alias")
  (autoload 'eshell-find-previous-directory "em-dirs")
  (autoload 'eshell/cd "em-dirs")
  (autoload 'ring-elements "ring")

  ;; Bash aliases from
  ;; https://emacs.stackexchange.com/questions/74385/is-there-any-way-of-making-eshell-aliases-using-bash-and-zsh-aliases-syntax
  (defun eshell-load-bash-aliases ()
    "Read Bash aliases and add them to the list of eshell aliases."
    ;; Bash needs to be run - temporarily - interactively
    ;; in order to get the list of aliases.
    (with-temp-buffer
      (call-process "bash" nil '(t nil) nil "-ci" "alias")
      (goto-char (point-min))
      (cl-letf (((symbol-function 'eshell-write-aliases-list) #'ignore))
        (while (re-search-forward "alias \\(.+\\)='\\(.+\\)'$" nil t)
          (eshell/alias (match-string 1) (format "%s $*" (match-string 2)))))
      (eshell-write-aliases-list)))

  ;; from https://karthinks.com/software/jumping-directories-in-eshell/
  (defvar consult-dir-sources)
  (defvar eshell-last-dir-ring)

  (defun init-eshell-set-visual-commands ()
    (setq eshell-visual-commands (append '("nix" "psy") eshell-visual-commands)))
  :hook
  (eshell-mode-hook . init-eshell-set-visual-commands)
  ;; We only want Bash aliases to be loaded when Eshell loads its own aliases,
  ;; rather than every time `eshell-mode' is enabled.
  (eshell-alias-load-hook . eshell-load-bash-aliases)
  :config
  (defun eshell/z (&optional regexp)
    "Navigate to a previously visited directory in eshell, or to
any directory proferred by `consult-dir'."
    (let ((eshell-dirs (delete-dups
                        (mapcar 'abbreviate-file-name
                                (ring-elements eshell-last-dir-ring)))))
      (require 'consult-dir nil 'noerror)
      (cond
       ((and (not regexp) (featurep 'consult-dir))
        (let* ((consult-dir--source-eshell `(:name "Eshell"
                                                   :narrow ?e
                                                   :category file
                                                   :face consult-file
                                                   :items ,eshell-dirs))
               (consult-dir-sources (cons consult-dir--source-eshell
                                          consult-dir-sources)))
          (eshell/cd (substring-no-properties
                      (consult-dir--pick "Switch directory: ")))))
       (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                       (completing-read "cd: " eshell-dirs))))))))

#+end_src

** Windowing

#+begin_src emacs-lisp :tangle init.el
;; undo+redo window changes
(use-package winner
  :init
  (winner-mode t))

;; avy style winodw navigation + editing
(use-package ace-window
  :ensure t
  :init
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (setq aw-dispatch-always t)
  :bind ("M-o" . ace-window))

(use-package bufler
  :ensure t
  :commands bufler-mode
  :config
  (bufler-mode))

(use-package burly
  :ensure t)
#+end_src

** Undo/redo

*** Vundo

#+begin_src emacs-lisp :tangle init.el
(use-package vundo
  :ensure t)
#+end_src

** Keybinding Help

Using embark prefix instead. Type `C-h` after a prefix instead. Then can
press `@` to use a keybinding (or do completing-read)

#+begin_src emacs-lisp :tangle no
(use-package which-key
  :commands which-key-mode
  :functions which-key--hide-popup which-key--create-buffer-and-show
  :config
  (which-key-mode)
  :blackout)
#+end_src

** Git

#+begin_src emacs-lisp :tangle init.el

(use-package smerge-mode
  ;; builtin
  :config
  (repeatify 'smerge-basic-map))

(use-package git-timemachine
  :ensure t)

;; Forges

;; (use-package consult-gh
;;   :ensure t
;;   :after consult)

;; (use-package forge
;;  :after magit)

(use-package browse-at-remote
  :ensure t)

;; Magit
(use-package magit-delta
  :ensure t
  :hook (magit-mode-hook . magit-delta-mode))

(use-package magit
  :ensure t)

;; diff highlighting

;; https://github.com/doomemacs/doomemacs/blob/98d753e1036f76551ccaa61f5c810782cda3b48a/modules/ui/vc-gutter/config.el#L34
(use-package diff-hl
  :ensure t
  :commands diff-hl-stage-current-hunk diff-hl-revert-hunk diff-hl-next-hunk diff-hl-previous-hunk
  :custom
  (vc-git-diff-switches '("--histogram"))
  :preface
  (defun diff-hl-define-thin-bitmaps (&rest _)
    (define-fringe-bitmap 'diff-hl-bmp-middle [240] nil nil '(center repeated))
    (define-fringe-bitmap 'diff-hl-bmp-delete [240 240 224 224 192 192 128 128] nil nil 'top))
  (defun diff-hl-type-face-fn (type _pos)
    (intern (format "diff-hl-%s" type)))
  (defun diff-hl-type-at-pos-fn (type _pos)
    (if (eq type 'delete)
        'diff-hl-bmp-delete
      'diff-hl-bmp-middle))
  (defun diff-hl-fix-faces ()
    (mapc
     (lambda (&rest args)
       (apply #'set-face-background (append args '(nil))))
     '(diff-hl-insert diff-hl-delete diff-hl-change)))
  :hook
  (find-file-hook . diff-hl-mode)
  (vc-dir-mode-hook . diff-hl-dir-mode)
  (dired-mode-hook . diff-hl-dired-mode)
  (magit-post-refresh-hook . diff-hl-magit-post-refresh)
  (magit-pre-refresh-hook . diff-hl-magit-pre-refresh)
  (diff-hl-mode-hook . diff-hl-flydiff-mode)
  (diff-hl-mode-hook . diff-hl-fix-faces)
  :init
  (advice-add 'diff-hl-define-bitmaps :override #'diff-hl-define-thin-bitmaps)
  (advice-add 'diff-hl-fringe-bmp-from-pos :override #'diff-hl-type-at-pos-fn)
  (advice-add 'diff-hl-fringe-bmp-from-type :override #'diff-hl-type-at-pos-fn))

(if (fboundp 'fringe-mode) (fringe-mode '8))
(setq-default fringes-outside-margins t)

#+end_src

** Uncategorized

#+begin_src emacs-lisp :tangle init.el
;; Operate on grep buffer

(use-package wgrep
  :ensure t)

;; Dired

(use-package wdired)

(use-package diredfl
  :ensure t
  :commands diredfl-global-mode
  :init
  (diredfl-global-mode))

;; Keymap Actions

(use-package embark
  :ensure t
  :bind (("C-." . embark-act)         ;; pick some comfortable binding
         ("C-;" . embark-dwim)        ;; good alternative: M-.
         ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings
  :functions embark-prefix-help-command
  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

(use-package embark-consult
  :ensure t
  :after (embark consult)
  :hook
  ;; if you want to have consult previews as you move around
  ;; an auto-updating embark collect buffer
  (embark-collect-mode-hook . consult-preview-at-point-mode))


;; Completion style

(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless partial-completion basic))
  (setq completion-category-defaults nil)
  (setq completion-category-overrides '((file (styles partial-completion)))))

;; Snippets

(use-package tempel
  :ensure t
  :commands tempel-expand
  :preface
  (defun my/tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions`
    (add-hook 'completion-at-point-functions
               #'tempel-expand t t))
  :init
  (add-hook 'conf-mode-hook 'my/tempel-setup-capf)
  (add-hook 'prog-mode-hook 'my/tempel-setup-capf)
  (add-hook 'text-mode-hook 'my/tempel-setup-capf))

(use-package lsp-snippet-tempel
  :ensure t
  ;; Installed through nix flake as git repo
  :after lsp-mode
  :functions lsp-snippet-tempel-eglot-init lsp-snippet-tempel-lsp-mode-init
  :config
  (when (featurep 'lsp-mode)
    (lsp-snippet-tempel-lsp-mode-init))
  (when (featurep 'eglot)
    (lsp-snippet-tempel-eglot-init))
  )

;; Completion at point functions + capf UI

;; https://kristofferbalintona.me/posts/202203130102/
(use-package cape
  :ensure t
  :bind ("C-c p p" . completion-at-point) ;; capf
  ("C-c p t" . complete-tag)              ;; etags
  ("C-c p d" . cape-dabbrev)              ;; or dabbrev-completion
  ("C-c p h" . cape-history)
  ("C-c p f" . cape-file)
  ("C-c p k" . cape-keyword)
  ("C-c p s" . cape-elisp-symbol)
  ("C-c p e" . cape-elisp-block)
  ("C-c p a" . cape-abbrev)
  ("C-c p l" . cape-line)
  ("C-c p w" . cape-dict)
  ("C-c p :" . cape-emoji)
  ("C-c p \\" . cape-tex)
  ("C-c p _" . cape-tex)
  ("C-c p ^" . cape-tex)
  ("C-c p &" . cape-sgml)
  ("C-c p r" . cape-rfc1345)
  :init
  (add-hook 'completion-at-point-functions (cape-capf-nonexclusive #'cape-dabbrev) nil nil)
  (add-hook 'completion-at-point-functions (cape-capf-nonexclusive #'cape-file) nil nil)
  (add-hook 'completion-at-point-functions (cape-capf-nonexclusive #'cape-elisp-block) nil nil)
  :commands cape-wrap-buster cape-capf-super cape-capf-nonexclusive
  :defines cape-file-directory-must-exit
  :config
  ;; https://old.reddit.com/r/emacs/comments/19b8a83/capefile_fails_when_called_as_a_capf_but_works/
  (setq cape-file-directory-must-exit nil))
#+end_src

;; stuff for completion in region + corfu

**** Completion in region

#+begin_src emacs-lisp :tangle init.el
(use-package corfu
  :ensure t
  :commands (corfu-mode global-corfu-mode)
  :preface
  (defun corfu-send-shell (&rest _)
    "Send completion candidate when inside comint/eshell."
    (cond
     ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
      (eshell-send-input))
     ((and (derived-mode-p 'comint-mode)  (fboundp 'comint-send-input))
      (comint-send-input))))
  :custom
  (corfu-cycle t)
  (corfu-preselect 'valid)
  (corfu-quit-no-match 'separator)
  (corfu-auto t)
  (corfu-min-width 60)
  (corfu-max-width corfu-min-width)
  (corfu-count 14)
  (corfu-scroll-margin 4)
  (corfu-echo-mode nil) ; Using corfu-popupinfo
  (corfu-popupinfo-delay '(0.2 . 1.0))
  :bind
  (:map corfu-map ;; use TAB for cycling, default is `corfu-complete`
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
        ;; configure M-SPC for seprator insertion
        ("M-SPC" . corfu-insert-separator)
        ("S-<return>" . corfu-insert)
        ("RET" . nil) ;; leave enter alone
        )
  :hook
  (corfu-mode-hook . corfu-popupinfo-mode)
  :config
  (add-hook 'eshell-mode-hook (lambda ()
                                (setq-local corfu-auto nil)
                                (corfu-mode)))
  (advice-add #'corfu-insert :after #'corfu-send-shell)
  ;; (lsp-completion-mode . my/corfu-setup-lsp) ;; use corfu for lsp
  :init
  (global-corfu-mode 1))


(use-package kind-icon
  :ensure t
  :after corfu
  :custom
  (kind-icon-use-icons t)
  (kind-icon-default-face 'corfu-default)
  (kind-icon-blend-background nil)
  (kind-icon-blend-frac 0.08)
  ;;(svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache"))
  :functions kind-icon-reset-cache kind-icon-margin-formatter
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
  (add-hook 'my/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))
#+end_src

Consult/vertico/marginalia

#+begin_src emacs-lisp :tangle init.el
;; minibuffer

(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
  :functions marginalia-mode
  :init
  (marginalia-mode))

(use-package vertico
  :ensure t
  :defines vertico-multiform-categories
  :init
  (setq embark-indicators
        '(embark-minimal-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  :hook
  (after-init-hook . vertico-mode)
  :custom
  (vertico-multiform-mode t)
  (vertico-cycle t)
  (vertico-reverse-mode t)
  (vertico-resize t)
  :config
  (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))
  )

;; Example configuration for Consult
(use-package consult
  :ensure t
  :defer 2
  :preface
  (autoload 'consult-xref "consult-xref")
  :functions consult-register-window consult-register-format
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c K" . consult-kmacro) ;; C-c k is used by meow
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x C-d" . consult-dir)
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g F" . consult-lsp-diagnostics)
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("M-g l" . consult-lsp-file-symbols)
         ("M-g L" . consult-lsp-symbols)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-fd)                  ;; Alternative: consult-find
         ("M-s c" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file)
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element
  ;; The :init configuration is always executed (Not lazy)
  :init
  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)
  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)
  ;; Use Consult to select xref locations with preview
  (eval-when-compile (require 'xref))
  (with-eval-after-load 'xref
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref))
  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config
  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; "C-+"
  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
            ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
            ;;;; 2. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
            ;;;; 3. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
            ;;;; 4. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
            ;;;; 5. No project support
  ;; (setq consult-project-function nil)
  )

(use-package consult-todo
  :ensure t
  :after (consult hl-todo))

(use-package consult-dir
  :ensure t
  :functions consult-dir--pick
  :after consult)

#+end_src

** Projects

Add a nix-project-finder. Need to make sure it is before the vc project finder.
breadcrumb-mode calls project-current, and the vc project finder has horrific
performance in the `/nix/store` directory. Profiler had it at 50%. So the function
is useful and good for performance.

#+begin_src emacs-lisp :tangle init.el
(use-package project
  :preface
  ;; A subdirectory of /nix/store
  (defun nix-project-finder (dir)
    (let ((nix-store-prefix "/nix/store/")
          (dirs (split-string (expand-file-name dir) "/")))
      (when (and (> (length dirs) 3)
                 (string-prefix-p nix-store-prefix dir))
        (cons 'transient (mapconcat 'identity (seq-take dirs 4) "/")))))
  :config
  (add-hook 'project-find-functions 'nix-project-finder))
#+end_src

** Motions


*** Avy

#+begin_src emacs-lisp :tangle init.el
(use-package avy
  :ensure t
  :bind
  ("C-:" . avy-goto-char))
#+end_src

*** View mode (disabled)

View mode for meow

#+begin_src emacs-lisp :tangle no
;; In order for the bindings in this prefix to remain active until you
;; press ESC (or some other key not bound under the prefix), you must
;; have `repeat-mode' enabled.
;; https://github.com/meow-edit/meow/discussions/368#discussioncomment-4219587
(defvar my-view-prefix)
(define-prefix-command 'my-view-prefix)
(define-key mode-specific-map (kbd "v") 'my-view-prefix)
(defvar my-view-rep-map (make-sparse-keymap))
(dolist (kb '(("@"    . View-back-to-mark)
              ("%"    . View-goto-percent)
              ("G"    . View-goto-line-last)
              ("g"    . View-goto-line)
              ("F"    . View-revert-buffer-scroll-page-forward)
              ("k"    . View-scroll-line-backward)
              ("j"    . View-scroll-line-forward)
              ("u"    . View-scroll-half-page-backward)
              ("d"    . View-scroll-half-page-forward)
              ("z"    . View-scroll-page-forward-set-page-size)
              ("w"    . View-scroll-page-backward-set-page-size)
              ("b"    . View-scroll-page-backward)
              ("f"    . View-scroll-page-forward)
              ("o"    . View-scroll-to-buffer-end)))
  (define-key my-view-prefix (kbd (car kb)) (cdr kb))
  (define-key my-view-rep-map (kbd (car kb)) (cdr kb))
  (put (cdr kb) 'repeat-map my-view-rep-map)
  (autoload (cdr kb) "view" nil 'interactive))
#+end_src

*** Meow (disabled)

#+begin_src emacs-lisp :tangle no
(use-package meow
  :ensure t
  :after avy
  :demand t
  :commands (meow-global-mode)
  :preface
  (autoload 'meow--selection-type "meow-util")
  (autoload 'meow--beacon-inside-secondary-selection "meow-util")
  (autoload 'meow--narrow-secondary-selection "meow-util")
  (autoload 'meow--beacon-shrink-selection  "meow-beacon")
  (autoload 'meow--beacon-add-overlay-at-point "meow-beacon")
  (autoload 'meow--make-selection "meow-command")
  (autoload 'meow--select "meow-command")
  (autoload 'meow-normal-define-key "meow")
  (autoload 'meow-leader-define-key "meow")
  (autoload 'meow-motion-overwrite-define-key "meow")
  (defun meow-setup ()
    (require 'meow-cheatsheet)
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (setq meow-goto-line-function 'consult-goto-line)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-avy-goto-char)
     '("F" . meow-avy-goto-char-expand)
     '("t" . meow-till)
     '("T" . meow-till-expand)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore)))

  (defvar meow--last-avy-char)
  (defun meow-avy-goto-char (char &optional arg expand)
    "Goto using avy"
    (interactive (list (read-char "goto: " t)
                       current-prefix-arg))
    (let* ((beg (point))
           (end (save-mark-and-excursion
                  (avy-goto-char char arg)
                  (point))))
      (thread-first
        (meow--make-selection '(select . avy)
                              beg end expand)
        (meow--select)))
    (setq meow--last-avy-char char))

  (defun meow-avy-goto-char-expand (char &optional arg)
    "Goto using avy expand"
    (interactive (list (read-char "Expand goto: " t)
                       current-prefix-arg))
    (meow-avy-goto-char char arg t))

  (defun meow--add-beacons-for-avy ()
    "Add beacon for avy movement"
    (let ((ch-str (if (eq meow--last-avy-char 13)
                      "\n"
                    (char-to-string meow--last-avy-char))))
      (save-restriction
        (meow--narrow-secondary-selection)
        (let ((orig (point))
              (case-fold-search t))
          (save-mark-and-excursion
            (goto-char (point-max))
            (while (search-backward ch-str nil t)
              (unless (= (point) orig)
                (meow--beacon-add-overlay-at-point (point)))))))
      (meow--beacon-shrink-selection)))

  (defun meow--beacon-update-overlays-custom ()
    (when (meow--beacon-inside-secondary-selection)
      (let* ((type (cdr (meow--selection-type))))
        (cl-case type
          ((avy) (meow--add-beacons-for-avy)))))))

(require 'meow)
(meow-setup)
(advice-add 'meow--beacon-update-overlays :after #'meow--beacon-update-overlays-custom)
(meow-global-mode 1)
#+end_src

** Visuals

*** Breadcrumbs

#+begin_src emacs-lisp :tangle init.el
(use-package breadcrumb
  :ensure t
  :commands (breadcrumb-mode breadcrumb-local-mode)
  :init
  (breadcrumb-mode))
#+end_src

** Diagnostics

*** Flymake

#+begin_src emacs-lisp :tangle init.el
(use-package flymake
  :defer t
  :hook ((prog-mode-hook text-mode-hook) . flymake-mode)
  :config
  (setq flymake-fringe-indicator-position 'right-fringe))
#+end_src

*** Flycheck (disabled)

#+begin_src emacs-lisp :tangle no
(use-package consult-flycheck
  :ensure t
  :after (consult flycheck))

(use-package flycheck
  :ensure t
  :commands flycheck-list-errors flycheck-buffer
  :functions flycheck-redefine-standard-error-levels
  :custom
  (flycheck-indication-mode 'right-fringe)
  (flycheck-display-errors delay 0.25)
  (flycheck-idle-change-delay 1.0)
  :hook
  (first-buffer-hook . global-flycheck-mode)
  :config
  (flycheck-redefine-standard-error-levels nil 'my-flycheck-fringe-bitmap-arrow)
  :init
  (define-fringe-bitmap 'my-flycheck-fringe-bitmap-arrow [16 48 112 240 112 48 16] nil nil 'center))

;; (use-package flycheck-inline
;;   :ensure t
;;   :after flycheck
;;   :init (global-flycheck-inline-mode))

#+end_src

** LSP

*** eglot

For some reason eglot-booster-mode turns on but not early enough to wrap the server
startup when doing `:before eglot` so just load it on startup.

#+begin_src emacs-lisp :tangle init.el
(use-package eglot-booster
  :ensure t
  :commands (eglot-booster-mode)
  :init
  (eglot-booster-mode))

(use-package consult-eglot
  :ensure t
  :after consult)

(use-package eglot
  :commands (eglot eglot-ensure)
  :functions eglot-completion-at-point
  :preface
  (defun my/eglot-setup-capf ()
    (setq-local completion-at-point-functions
                (append (list (cape-capf-nonexclusive
                               (cape-capf-super
                                #'eglot-completion-at-point
                                #'tempel-expand)))
                        (default-value 'completion-at-point-functions))))
  (defun my/eglot-disable-on-type-formatting ()
    (setq-local eglot-ignored-server-capabilities
                (cons :documentOnTypeFormattingProvider
                      eglot-ignored-server-capabilities)))
  :hook
  (eglot-managed-mode-hook . my/eglot-setup-capf)
  (c-mode-hook . my/eglot-disable-on-type-formatting)
  (c++-mode-hook . my/eglot-disable-on-type-formatting)
  :init
  (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
  :custom
  (lsp-completion-provider :none) ; use corfu intsead for lsp completion
  :config
  (setq eglot-autoshutdown t)
  (setq completion-category-defaults nil)
  :custom-face
  (eglot-highlight-symbol-face ((t (:underline t :weight bold)))))
#+end_src

*** LSP mode (disabled)

#+begin_src emacs-lisp :tangle no
(setq lsp-keymap-prefix "C-c l")

(use-package consult-lsp
  :ensure t
  :after (consult lsp))

(use-package lsp-mode
  :ensure t
  :commands (lsp lsp-deferred)
  :preface
  ;; (autoload 'lsp-enable-which-key-integration "lsp-mode")
  ;; (autoload 'lsp-diagnostics-mode "lsp-diagnostics")
  ;; (defun my/setup-lsp-mode ()
  ;;   (message "my/setup-lsp-mode called")
  ;;   (lsp-enable-which-key-integration)
  ;;   (lsp-diagnostics-mode t)
  ;;   ;; (when (lsp-feature? "textDocument/formatting")
  ;;   ;;  (setq my/format/buffer-function 'lsp-format-buffer))
  ;;   )
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))


  :custom
  (lsp-enable-symbol-highlighting t)
  (lsp-modeline-code-actions-enable t)
  (lsp-signature-auto-activate  t)
  (lsp-signature-render-documentation t)
  (lsp-diagnostics-provider :flycheck)
  (lsp-enable-indentation nil) ;; disabled indentation
  (lsp-enable-snippet t)
  (lsp-enable-xref t)
  (lsp-enable-imenu t)
  (lsp-inlay-hint-enable t)
  (lsp-enable-links t)
  (lsp-lens-enable t)
  (lsp-semantic-tokens-enable t)
  (lsp-enable-semantic-highlighting t)
  (read-process-output-max (* 1024 1024)) ;; 1mb
  (gc-cons-threshold (* 10 1024 1024))
  (lsp-log-io nil)
  ;; :hook (lsp-mode . my/setup-lsp-mode)
  :init
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command))

(use-package lsp-ui
  :ensure t
  :custom
  (lsp-ui-sideline-enable t)
  (lsp-ui-sideline-show-code-actions nil))

(use-package lsp-pyright
  :ensure t
  :hook (python-mode-hook . (lambda ()
                              (require 'lsp-pyright)
                              (lsp-deferred))))
#+end_src

** Debug

*** dape

Debug adapter client

#+begin_src emacs-lisp :tangle init.el
(use-package dape
  :ensure t
  :functions dape-breakpoint-global-mode
  :hook
  ((kill-emacs . dape-breakpoint-save)
   (after-init . dape-breakpoint-load))
  :config
  (setq dape-buffer-window-arrangement 'right)
  (dape-breakpoint-global-mode))
#+end_src

** Language configs

#+begin_src emacs-lisp :tangle init.el
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :hook (python-mode-hook . eglot-ensure))

;; Relies on projectile :(
;; (use-package python-pytest
;;   :ensure t)

;; Nix
(use-package nix-mode
  :ensure t
  :mode "\\.nix\\'"
  :hook (nix-mode-hook . eglot-ensure))

;; C/C++
(use-package cc-mode
  :ensure nil
  :preface
  (autoload 'c-indent-line-or-region "cc-cmds")
  (defun c-indent-then-complete ()
    (interactive)
    (if (= 0 (c-indent-line-or-region))
        (completion-at-point)))
  (defun c-indent-tabs-mode ()
    (setq indent-tabs-mode nil))
  :config
  ;; https://old.reddit.com/r/emacs/comments/u8szz6/help_me_get_c_tab_completion_working/
  (when (equal tab-always-indent 'complete)
    (dolist (map (list c-mode-map c++-mode-map))
      (define-key map (kbd "<tab>") #'c-indent-then-complete)))
  :hook ((c-mode-mook . eglot-ensure)
         (c-mode-hook . c-indent-tabs-mode)
         (c++-mode-hook . eglot-ensure)
         (c++-mode-hook . c-indent-tabs-mode)))

(use-package modern-cpp-font-lock
  :ensure t
  :after cc-mode
  :hook (c++-mode-hook . modern-c++-font-lock-mode))

(use-package zig-mode
  :hook (zig-mode-hook . eglot-ensure)
  :ensure t)

;; Go

(use-package go-mode
  :ensure t
  :hook (go-mode-hook . eglot-ensure))

;; Rust
(use-package rustic
  :ensure t
  :init
  (remove-hook 'rustic-mode-hook 'flycheck-mode)
  :custom
  (rustic-lsp-client 'eglot))

(use-package sh-script
  :hook (sh-mode-hook . eglot-ensure))

;; TODO: treesitter

;; (use-package tree-sitter
;;   :ensure t
;;   :hook (tree-sitter-after-on-hook . tree-sitter-hl-mode)
;;   :config
;;   (global-tree-sitter-mode))
;; (use-package tree-sitter-langs
;;   :ensure t)

;; Misc. editor

(use-package editorconfig
  :ensure t
  :commands editorconfig-mode
  :config
  (editorconfig-mode t)
  :blackout)

;; Formatting

;; Hook LSP and custom functions into apheleia formatting
;; https://github.com/radian-software/apheleia/issues/153
;;
;; (defun my/lsp-go-save-hooks ()
;;  (add-hook 'before-save-hook #'lsp-format-buffer t t)
;;  (add-hook 'before-save-hook #'lsp-organize-imports t t))

(use-package apheleia
  :ensure t
  :hook ((go-mode-hook . apheleia-mode)
         (python-mode-hook . apheleia-mode)
         (sh-mode-hook . apheleia-mode)
         (rust-mode-hook . apheleia-mode)
         (zig-mode-hook . apheleia-mode)
         (nix-mode-hook . apheleia-mode))
  :blackout " Fmt"
  :config
  (push '(zigfmt . (zig-zig-bin "fmt" "--stdin")) apheleia-formatters)
  (setf (alist-get 'python-mode apheleia-mode-alist) '(ruff)
        (alist-get 'zig-mode apheleia-mode-alist) '(zigfmt)
        (alist-get 'sh-mode apheleia-mode-alist) '(shfmt)))

(use-package devdocs
  :ensure t
  :defer t)

(use-package tldr
  :ensure t
  :custom
  ;; tldr unzips to tldr-main/ while tldr.el expects tldr/
  (tldr-directory-path (expand-file-name "tldr-main/" user-emacs-directory))
  :defer t)

;; direnv variables

;; hacks are from doom:
;; https://github.com/doomemacs/doomemacs/blob/98d753e1036f76551ccaa61f5c810782cda3b48a/modules/tools/direnv/config.el#L27
(use-package envrc
  :ensure t
  :preface
  (autoload 'envrc-propagate-environment "envrc")
  (autoload 'envrc-global-mode-enable-in-buffers "envrc")
  (autoload 'envrc--update "envrc")
  ;; Normally, envrc updates on 'after-change-major-mode-hook'. This is too
  ;; late; a mode's hooks might depend on environmental state that direnv sets
  ;; up (e.g. starting an LSP server that expects project-specific
  ;; envvars). Moved to `change-major-mode-after-body-hook' which runs before
  ;; those hooks, but not the body
  (defun direnv-init-global-mode-earlier ()
    (let ((fn #'envrc-global-mode-enable-in-buffers))
      (if (not envrc-global-mode)
          (remove-hook 'change-major-mode-after-body-hook fn)
        (remove-hook 'change-major-mode-after-body-hook fn)
        (add-hook 'change-major-mode-after-body-hook fn 100))))

  ;; Above hack causes envrc to trigger in its own, internal buffers, causing
  ;; extra direnv errors.
  ;; (defun direnv--debounce-update (&rest _)
  ;;  "Prevent direnv from running multiple times, consecutively in a buffer."
  ;;  (not (string-prefix-p "*envrc") (buffer-name)))
  :init
  ;; (advice-add #'envrc--update :before-while #'direnv--debounce-update)
  ;; (advice-add #'org-babel-execute-src-block :around #'envrc-propagate-environment)
  :hook
  (first-file-hook . envrc-global-mode))
;; (envrc-global-mode-hook . direnv-init-global-mode-earlier))

;; singlestore
(setq-default compile-command "memsql-please make debug") ; set default command for M-x compile
(setq-default gdb-create-source-file-list nil)  ; gdb initialization takes a long time without this
(setq-default word-wrap t)                      ; wrap long lines at word boundaries for better readability

;; Adjust C++ style to more closely match the style we use in the MemSQL codebase
(c-add-style "memsql"
             '("linux"
               (c-basic-offset . 4)
               (c-offsets-alist
                (inline-open . 0)
                (innamespace . 0)       ; don't indent inside namespaces
                )
               ))
(defvar c-default-style)
(add-to-list 'c-default-style '(c++-mode . "memsql"))

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode)) ; use c++-mode instead of c-mode for .h files
(setq-default indent-tabs-mode nil)

;; Default settings for sql-mysql
;; You can run a mysql/memsql client in Emacs with M-x sql-mysql

(defvar sql-user)
(defvar sql-password)
(defvar sql-server)
(setq sql-user "root")
(setq sql-password "")
(setq sql-server "127.0.0.1")
#+end_src

** Activity watch

#+begin_src emacs-lisp :tangle init.el
(use-package activity-watch-mode
  :ensure t
  :hook
  (first-file-hook . global-activity-watch-mode))
#+end_src
